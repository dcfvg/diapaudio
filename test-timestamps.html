<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timestamp Test</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    .error { color: red; }
    .success { color: green; }
    table { border-collapse: collapse; margin: 20px 0; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #f0f0f0; }
  </style>
</head>
<body>
  <h1>Timestamp Parsing Test</h1>
  <div id="output"></div>

  <script>
    function parseTimestampFromName(name) {
      const basename = name.split("/").pop() || name;
      const clean = basename.replace(/\.[^.]+$/, "");
      
      // Try various date-time formats
      const regexes = [
        // Full date-time formats: YYYY-MM-DD HH:MM:SS (various separators)
        /(\d{4})[-_]?(\d{2})[-_]?(\d{2})[ _-](\d{2})[.\-_:](\d{2})[.\-_:](\d{2})/,
        /(\d{4})(\d{2})(\d{2})[_-]?(\d{2})(\d{2})(\d{2})/,
        
        // Date with time: DD-MM-YYYY HH:MM:SS
        /(\d{2})[-_]?(\d{2})[-_]?(\d{4})[ _-](\d{2})[.\-_:](\d{2})[.\-_:](\d{2})/,
        
        // Time-only formats: HH.MM.SS or HH:MM:SS or HH-MM-SS (at start of filename)
        /^(\d{2})[.\-_:](\d{2})[.\-_:](\d{2})/,
      ];

      for (const regex of regexes) {
        const match = clean.match(regex);
        if (match) {
          // Check if this is a time-only format (3 groups)
          if (match.length === 4) {
            const [, hours, minutes, seconds] = match.map(Number);
            // Use a reference date (today) with the extracted time
            const now = new Date();
            const ts = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, seconds);
            if (!Number.isNaN(ts.getTime()) && hours < 24 && minutes < 60 && seconds < 60) {
              return ts;
            }
          }
          // Full date-time format (7 groups)
          else if (match.length === 7) {
            let [, p1, p2, p3, hours, minutes, seconds] = match.map(Number);
            let year, month, day;
            
            // Determine if it's YYYY-MM-DD or DD-MM-YYYY based on first value
            if (p1 > 1000) {
              // YYYY-MM-DD format
              year = p1;
              month = p2;
              day = p3;
            } else {
              // DD-MM-YYYY format
              day = p1;
              month = p2;
              year = p3;
            }
            
            // Validate and create date
            if (!isNaN(year) && year >= 1900 && year <= 2100 &&
                month >= 1 && month <= 12 &&
                day >= 1 && day <= 31 &&
                hours >= 0 && hours < 24 &&
                minutes >= 0 && minutes < 60 &&
                seconds >= 0 && seconds < 60) {
              const ts = new Date(year, month - 1, day, hours, minutes, seconds);
              if (!Number.isNaN(ts.getTime())) {
                return ts;
              }
            }
          }
        }
      }

      return null;
    }

    function formatTime(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      return h > 0 ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}` 
                   : `${m}:${s.toString().padStart(2, '0')}`;
    }

    // Test files
    const audioFiles = [
      '2025-10-08 08.41.10_00066_M1.WAV',
      '2025-10-08 09.51.14_00087_M2.WAV',
      '2025-10-08 10.10.50_00088_M2.WAV',
      '2025-10-08 10.37.22_00089_M2.WAV',
      '2025-10-08 10.52.22_00090_M2.WAV',
      '2025-10-08 10.55.26_00091_M2.WAV',
      '2025-10-08 11.18.00_00092_M2.WAV',
      '2025-10-08 11.22.26_00093_M2.WAV',
      '2025-10-08 12.22.28_00094_M2.WAV'
    ];

    const durations = [876.113333, 1173.256333, 1378.682667, 896.410000, 174.878333, 1221.417000, 267.343667, 3600.231000, 36.352333];

    const imageFiles = [
      '2025-10-08 10.03.23.jpg',
      '2025-10-08 10.03.25.jpg',
      '2025-10-08 11.08.48.jpg',
      '2025-10-08 11.17.43.jpg',
      '2025-10-08 14.40.28.jpg'
    ];

    const output = document.getElementById('output');
    
    // Test audio files
    output.innerHTML += '<h2>Audio Files (Timestamp at END)</h2>';
    output.innerHTML += '<table><tr><th>File</th><th>Timestamp</th><th>Duration</th><th>Start Time</th><th>End Time</th></tr>';
    
    audioFiles.forEach((file, i) => {
      const ts = parseTimestampFromName(file);
      const duration = durations[i];
      if (ts) {
        const endTime = ts.getTime();
        const startTime = endTime - (duration * 1000);
        output.innerHTML += `<tr>
          <td>${file}</td>
          <td class="success">${ts.toLocaleString()}</td>
          <td>${formatTime(duration)} (${duration.toFixed(1)}s)</td>
          <td>${new Date(startTime).toLocaleTimeString()}</td>
          <td>${new Date(endTime).toLocaleTimeString()}</td>
        </tr>`;
      } else {
        output.innerHTML += `<tr><td>${file}</td><td class="error">FAILED TO PARSE</td><td>-</td><td>-</td><td>-</td></tr>`;
      }
    });
    output.innerHTML += '</table>';

    // Test image files
    output.innerHTML += '<h2>Image Files</h2>';
    output.innerHTML += '<table><tr><th>File</th><th>Timestamp</th><th>Matches Track(s)</th></tr>';
    
    imageFiles.forEach(file => {
      const ts = parseTimestampFromName(file);
      if (ts) {
        const imageTime = ts.getTime();
        const matches = [];
        
        audioFiles.forEach((audioFile, i) => {
          const audioTs = parseTimestampFromName(audioFile);
          if (audioTs) {
            const duration = durations[i];
            const endTime = audioTs.getTime();
            const startTime = endTime - (duration * 1000);
            
            if (imageTime >= startTime && imageTime <= endTime) {
              matches.push(`Track ${i + 1} (${audioFile})`);
            }
          }
        });
        
        const matchStr = matches.length > 0 ? matches.join('<br>') : '<span class="error">NO MATCH</span>';
        const matchClass = matches.length > 1 ? 'error' : (matches.length === 1 ? 'success' : '');
        
        output.innerHTML += `<tr>
          <td>${file}</td>
          <td>${ts.toLocaleString()}</td>
          <td class="${matchClass}">${matchStr}</td>
        </tr>`;
      } else {
        output.innerHTML += `<tr><td>${file}</td><td class="error">FAILED TO PARSE</td><td>-</td></tr>`;
      }
    });
    output.innerHTML += '</table>';

    // Warning about overlaps
    output.innerHTML += '<h2>Overlapping Time Ranges</h2>';
    const overlaps = [];
    for (let i = 0; i < audioFiles.length; i++) {
      for (let j = i + 1; j < audioFiles.length; j++) {
        const ts1 = parseTimestampFromName(audioFiles[i]);
        const ts2 = parseTimestampFromName(audioFiles[j]);
        if (ts1 && ts2) {
          const start1 = ts1.getTime() - (durations[i] * 1000);
          const end1 = ts1.getTime();
          const start2 = ts2.getTime() - (durations[j] * 1000);
          const end2 = ts2.getTime();
          
          // Check if ranges overlap
          if (start1 <= end2 && start2 <= end1) {
            overlaps.push(`Track ${i + 1} and Track ${j + 1} overlap!`);
          }
        }
      }
    }
    
    if (overlaps.length > 0) {
      output.innerHTML += '<div class="error">' + overlaps.join('<br>') + '</div>';
    } else {
      output.innerHTML += '<div class="success">No overlaps detected</div>';
    }
  </script>
</body>
</html>
